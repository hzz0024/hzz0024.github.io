---
comments: true
title: Repeat challenge sequencing
date: '2021-01-22 12:00'
tags:
  - DelBay
  - Challenge
  - WGS
  - QC
categories:
  - WGS data analysis
--- 

The dataset in this post comes from the adult challenge experiment in summer, 2019. The reason I am re-analysing this dataset is due to haplotig-masked genome. An independent folder was created for this dataset - DelBay19. The major change from DelBay20 is the sample list and table. 

Before data QC, we need to create two files to provide the detailed information of sequenced samples.

sample_list.txt: sample prefix part before *_1.fastq.gz* or *_2.fastq.gz*
sample_table.txt: a tab deliminated table with the following six columns, strictly in this order:

  - `prefix` the prefix of raw fastq file names

  - `lane_number` lane number; each sequencing lane or batch should be
    assigned a unique identifier

  - `seq_id` sequence ID; this variable is only relevant when different
    libraries were prepared out of the same sample and were run in the
    same lane (e.g. if you wanted to include a replicate). In this case,
    seq\_id should be used to distinguish these separate libraries. If
    you only have a single library prepared from each of your samples
    (even if you sequence that same library across multiple lanes), you
    can just put 1 for all samples in this column.

  - `sample_id` sample ID; a unique identifier for each individual
    sequenced

  - `population` population name; the population or other relevant
    grouping variable that the individual belongs to

  - `data_type` data type; there can only be two possible entries: `pe`
    (for paired-end data) or `se` (for single end data). We need this in
    the table because for some of our processing steps, the commands are
    slightly different for paired-end and single-end data.

These two files are located at            
[HG_Code_Bay/sample_list/fastq_list.txt](https://github.com/hzz0024/HG_Code_Bay/blob/master/sample_list/fastq_list.txt)        
[HG_Code_Bay/sample_list/fastq_table.txt](https://github.com/hzz0024/HG_Code_Bay/blob/master/sample_list/fastq_table.txt)  

--- 

### QC and trimming

1) First is to look at the fastqc reports:

```sh
#!/bin/sh
FASTQC=/programs/FastQC-0.11.8/fastqc
BASEDIR=/workdir/hz269/DelBay20
SAMPLELIST=$BASEDIR/sample_lists/fastq_list.txt
RAWFASTQSUFFIX1=_1.fq.gz # Suffix to raw fastq files. Use forward reads with paired-end data.

for SAMPLE in `cat $SAMPLELIST`; do

  $FASTQC $BASEDIR'/raw_fastq/'$SAMPLE$RAWFASTQSUFFIX1 -o $BASEDIR'/fastqc/'
done
```

2) Adapter clipping

Trimmomatic has lots of different filtering modules. Here I clip sequence that match to our adapter sequence (TruSeq3-PE-2.fa) and remove reads that end up being < 80bp after clipping.

```sh
cat 2_trim.sh
start=`date +%s`  ## date at start
BASEDIR=/workdir/hz269/DelBay19
TRIMMOMATIC=/programs/trimmomatic/trimmomatic-0.39.jar
SAMPLELIST=$BASEDIR/sample_lists/fastq_list_test.txt # Path to a list of prefixes of the raw fastq files. It should be a subset of the the 1st column of the sample table.
SAMPLETABLE=$BASEDIR/sample_lists/fastq_table.txt # Path to a sample table where the 1st column is the prefix of the raw fastq files. The 4th column is the sample ID, the 2nd column is the lane number, and the 3rd column is sequence ID. The combination of these three columns have to be unique. The 6th column should be data type, which is either pe or se. 
RAWFASTQDIR=$BASEDIR/raw_fastq/ # Path to raw fastq files. 
RAWFASTQSUFFIX1=_1.fq.gz # Suffix to raw fastq files. Use forward reads with paired-end data.
RAWFASTQSUFFIX2=_2.fq.gz # Suffix to raw fastq files. Use reverse reads with paired-end data. 
ADAPTERS=$BASEDIR/reference/NexteraPE-PE.fa # Path to a list of adapter/index sequences, copied from /programs/trimmomatic/adapters/

## Loop over each sample
for SAMPLEFILE in `cat $SAMPLELIST`; do
    ## Extract relevant values from a table of sample, sequencing, and lane ID (here in columns 4, 3, 2, respectively) for each sequenced library
    SAMPLE_ID=`grep -P "${SAMPLEFILE}\t" $SAMPLETABLE | cut -f 4`
    POP_ID=`grep -P "${SAMPLEFILE}\t" $SAMPLETABLE | cut -f 5`
    SEQ_ID=`grep -P "${SAMPLEFILE}\t" $SAMPLETABLE | cut -f 3`
    LANE_ID=`grep -P "${SAMPLEFILE}\t" $SAMPLETABLE | cut -f 2`
    SAMPLE_UNIQ_ID=$SAMPLE_ID'_'$POP_ID'_'$SEQ_ID'_'$LANE_ID  # When a sample has been sequenced in multiple lanes, we need to be able to identify the files from each run uniquely
    echo "Sample: $SAMPLE_UNIQ_ID"
    ## Extract data type from the sample table
    DATATYPE=`grep -P "${SAMPLEFILE}\t" $SAMPLETABLE | cut -f 6`
    
    ## The input and output path and file prefix
    RAWFASTQ_ID=$RAWFASTQDIR$SAMPLEFILE
    SAMPLEADAPT=$BASEDIR'/adapter_clipped/'$SAMPLE_UNIQ_ID
    
    ## Adapter clip the reads with Trimmomatic
    # The options for ILLUMINACLIP are: ILLUMINACLIP:<fastaWithAdaptersEtc>:<seed mismatches>:<palindrome clip threshold>:<simple clip threshold>:<minAdapterLength>:<keepBothReads>
    # The MINLENGTH drops the read if it is below the specified length in bp
    # For definitions of these options, see http://www.usadellab.org/cms/uploads/supplementary/Trimmomatic/TrimmomaticManual_V0.32.pdf
    

    if [ $DATATYPE = pe ]; then
        java -jar $TRIMMOMATIC PE -threads 1 -phred33 $RAWFASTQ_ID$RAWFASTQSUFFIX1 $RAWFASTQ_ID$RAWFASTQSUFFIX2 $SAMPLEADAPT'_adapter_clipped_f_paired.fastq.gz' $SAMPLEADAPT'_adapter_clipped_f_unpaired.fastq.gz' $SAMPLEADAPT'_adapter_clipped_r_paired.fastq.gz' $SAMPLEADAPT'_adapter_clipped_r_unpaired.fastq.gz' 'ILLUMINACLIP:'$ADAPTERS':2:30:10:1:true MINLENGTH:80' 
    
    elif [ $DATATYPE = se ]; then
        java -jar $TRIMMOMATIC SE -threads 1 -phred33 $RAWFASTQ_ID$RAWFASTQSUFFIX1 $SAMPLEADAPT'_adapter_clipped_se.fastq.gz' 'ILLUMINACLIP:'$ADAPTERS':2:30:10 MINLENGTH:40'
    fi
    
done

end=`date +%s`  ## date at end
runtime=$((end-start))
hours=$((runtime / 3600))
minutes=$(( (runtime % 3600) / 60 ))
seconds=$(( (runtime % 3600) % 60 )) 
echo "Runtime: $hours:$minutes:$seconds (hh:mm:ss)"


    ## Adapter clip the reads with Trimmomatic
    # The options for ILLUMINACLIP are: ILLUMINACLIP:<fastaWithAdaptersEtc>:<seed mismatches>:<palindrome clip threshold>:<simple clip threshold>:<minAdapterLength>:<keepBothReads>

# to run the script
for i in {1..19}; do
    nohup sh '2_trim_'$i'.sh' > '2_trim_'$i'.log' &
done
```

3) Build reference index files

```sh
cat 3_build_ref.sh

BASEDIR=/workdir/hz269/DelBay20
PICARD=/programs/picard-tools-2.19.2/picard.jar
SAMTOOLS=/programs/samtools-1.11/bin/samtools
BOWTIEBUILD=/programs/bowtie2-2.3.5.1-linux-x86_64/bowtie2-build
REFERENCE=$BASEDIR/reference/CV30_masked.fasta   # This is a fasta file with the reference genome sequence we will map to
REFBASENAME="${REFERENCE%.*}"
$SAMTOOLS faidx $REFERENCE

java -jar $PICARD CreateSequenceDictionary R=$REFERENCE O=$REFBASENAME'.dict'
```

4) Map to the reference, sort, and quality filter

```sh
start=`date +%s` 
BASEDIR=/workdir/hz269/DelBay20
BOWTIE=/programs/bowtie2-2.3.5.1-linux-x86_64/bowtie2
SAMTOOLS=/programs/samtools-1.11/bin/samtools
SAMPLELIST=$BASEDIR/sample_lists/fastq_list_test.txt # Path to a list of prefixes of the raw fastq files. It should be a subset of the the 1st column of the sample table.
SAMPLETABLE=$BASEDIR/sample_lists/fastq_table.txt # Path to a sample table where the 1st column is the prefix of the raw fastq files. The 4th column is the sample ID, the 2nd column is the lane number, and the 3rd column is sequence ID. The combination of these three columns have to be unique. The 6th column should be data type, which is either pe or se.
FASTQDIR=$BASEDIR/adapter_clipped/ # Path to the directory where fastq file are stored.
FASTQSUFFIX1=_adapter_clipped_f_paired.fastq.gz # Suffix to fastq files. Use forward reads with paired-end data.
FASTQSUFFIX2=_adapter_clipped_r_paired.fastq.gz # Suffix to fastq files. Use reverse reads with paired-end data.
MAPPINGPRESET=very-sensitive # The pre-set option to use for mapping in bowtie2 (very-sensitive for end-to-end (global) mapping [typically used when we have a full genome reference], very-sensitive-local for partial read mapping that allows soft-clipping [typically used when mapping genomic reads to a transcriptome]
REFERENCE=$BASEDIR/reference/CV30_masked.fasta # Path to reference fasta file and file name
REFNAME=CV30_masked # Reference name to add to output files, e.g. gadMor2

## Loop over each sample
for SAMPLEFILE in `cat $SAMPLELIST`; do

  ## Extract relevant values from a table of sample, sequencing, and lane ID (here in columns 4, 3, 2, respectively) for each sequenced library
  SAMPLE_ID=`grep -P "${SAMPLEFILE}\t" $SAMPLETABLE | cut -f 4`
  POP_ID=`grep -P "${SAMPLEFILE}\t" $SAMPLETABLE | cut -f 5`
  SEQ_ID=`grep -P "${SAMPLEFILE}\t" $SAMPLETABLE | cut -f 3`
  LANE_ID=`grep -P "${SAMPLEFILE}\t" $SAMPLETABLE | cut -f 2`
  SAMPLE_UNIQ_ID=$SAMPLE_ID'_'$POP_ID'_'$SEQ_ID'_'$LANE_ID  # When a sample has been sequenced in multiple lanes, we need to be able to identify the files from each run uniquely

  ## Extract data type from the sample table
  DATATYPE=`grep -P "${SAMPLEFILE}\t" $SAMPLETABLE | cut -f 6`

  ## The input and output path and file prefix
  SAMPLETOMAP=$FASTQDIR$SAMPLE_UNIQ_ID
  SAMPLEBAM=$BASEDIR'/bam/'$SAMPLE_UNIQ_ID

  ## Define platform unit (PU), which is the lane number
  PU=`grep -P "${SAMPLEFILE}\t" $SAMPLETABLE | cut -f 2`

  ## Define reference base name
  REFBASENAME="${REFERENCE%.*}"

  ## Map reads to the reference
  echo $SAMPLE_UNIQ_ID

  # Map the paired-end reads
  if [ $DATATYPE = pe ]; then
  # We ignore the reads that get orphaned during adapter clipping because that is typically a very small proportion of reads. If a large proportion of reads get orphaned (loose their mate so they become single-end), these can be mapped in a separate step and the resulting bam files merged with the paired-end mapped reads.
  $BOWTIE -q --phred33 --$MAPPINGPRESET -p 1 -I 0 -X 1500 --fr --rg-id $SAMPLE_UNIQ_ID --rg SM:$SAMPLE_ID --rg LB:$SAMPLE_ID --rg PU:$PU --rg PL:ILLUMINA -x $REFBASENAME -1 $SAMPLETOMAP$FASTQSUFFIX1 -2 $SAMPLETOMAP$FASTQSUFFIX2 -S $SAMPLEBAM'_'$DATATYPE'_bt2_'$REFNAME'.sam'

  # Map the single-end reads
  elif [ $DATATYPE = se ]; then
  $BOWTIE -q --phred33 --$MAPPINGPRESET -p 1 --rg-id $SAMPLE_UNIQ_ID --rg SM:$SAMPLE_ID --rg LB:$SAMPLE_ID --rg PU:$PU --rg PL:ILLUMINA -x $REFBASENAME -U $SAMPLETOMAP$FASTQSUFFIX1 -S $SAMPLEBAM'_'$DATATYPE'_bt2_'$REFNAME'.sam'

  fi

  ## Convert to bam file for storage (including all the mapped reads)
  $SAMTOOLS view -bS -F 4 $SAMPLEBAM'_'$DATATYPE'_bt2_'$REFNAME'.sam' > $SAMPLEBAM'_'$DATATYPE'_bt2_'$REFNAME'.bam'
  rm -f $SAMPLEBAM'_'$DATATYPE'_bt2_'$REFNAME'.sam'

  ## Filter the mapped reads (to onky retain reads with high mapping quality)
  # Filter bam files to remove poorly mapped reads (non-unique mappings and mappings with a quality score < 20)
  $SAMTOOLS view -h -q 20 $SAMPLEBAM'_'$DATATYPE'_bt2_'$REFNAME'.bam' | $SAMTOOLS view -buS - | $SAMTOOLS sort -o $SAMPLEBAM'_'$DATATYPE'_bt2_'$REFNAME'_minq20_sorted.bam'

done

end=`date +%s` ## date at end
runtime=$((end-start))
hours=$((runtime / 3600))
minutes=$(( (runtime % 3600) / 60 ))
seconds=$(( (runtime % 3600) % 60 ))
echo "Runtime: $hours:$minutes:$seconds (hh:mm:ss)"

# to run the script
for i in {1..19}; do
    nohup sh '4_map_'$i'.sh' > '4_map_'$i'.log' &
done
```









